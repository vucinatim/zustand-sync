// src/server/StoreController.ts (THE NEW GENERIC ENGINE)

import { createStore, type StoreApi } from "zustand/vanilla";
import { produceWithPatches, enablePatches, type Patch } from "immer";

enablePatches();

// This controller wraps a vanilla Zustand store on the server.
export class StoreController<TState extends { actions: Record<string, any> }> {
  private store: StoreApi<TState>;
  private lastPatches: Patch[] = [];

  constructor(initializer: (set: any, get: any) => TState) {
    // 1. Create a headless Zustand store instance for this room.
    this.store = createStore(initializer);

    // 2. Subscribe to all state changes in this store instance.
    this.store.subscribe((newState, prevState) => {
      // 3. When state changes, compare the previous and new states to generate patches.
      const [, patches] = produceWithPatches(prevState, () => newState);
      // 4. Store these patches to be retrieved by the dispatch method.
      this.lastPatches = patches;
    });
  }

  public getState() {
    return this.store.getState();
  }

  // This is the generic action dispatcher. It's now very simple.
  public dispatch(
    actionName: string,
    args: unknown[],
    senderId: string
  ): Patch[] {
    // A. Clear any patches from the previous dispatch.
    this.lastPatches = [];

    const actionToRun = this.store.getState().actions[actionName];
    if (!actionToRun) {
      console.warn(`Action "${actionName}" not found on server store.`);
      return [];
    }

    // B. Run the action. It will call `set` internally, which triggers our `subscribe` listener.
    actionToRun(...args, senderId);

    // C. Return the patches that were generated by the `subscribe` listener.
    return this.lastPatches;
  }
}
